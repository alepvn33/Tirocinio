

# This file was *autogenerated* from the file test_compressed_rest_CVE.sage
from sage.all_cmdline import *   # import sage library

_sage_const_19 = Integer(19); _sage_const_148 = Integer(148); _sage_const_84 = Integer(84); _sage_const_128 = Integer(128); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)#one round simulation    
reset();
import hashlib;
load('rest_CVE_utils.sage')

q = _sage_const_19 ;
n = _sage_const_148 ;
r = _sage_const_84 ;
N=_sage_const_128 ;

#Preparing for executing the protocol
Fq=GF(q);
Fq_set = Set(Fq);
Fq_star = Fq_set.difference([_sage_const_0 ]);
P = Permutations(range(_sage_const_0 ,n));

#Key generation
e,Htr_unsys,s = key_gen(Fq,n,r);



##Generating N committments
big_c = []; #it is the overall commitment
tau_u_matrix = matrix(Fq,N,n); #it contains the N vectors u, for all rounds
tau_perm_matrix = matrix(ZZ,N,n); #it contains the N permutations, for all rounds
tau_values_matrix = matrix(Fq,N,n); #it contains the N scaling vectors, for all rounds
tau_e_matrix = matrix(Fq,N,n);

comm_hashes=[];    
#Proceeding with remaining rounds
for i in range(_sage_const_0 ,N):
    
    #Generating a random u and a random restricted monomial
    u = random_matrix(Fq,_sage_const_1 ,n);
    tau_perm = P.random_element();
    tau_values = rnd_restricted_vector(Fq,n);

    #Apply monomial to tau_e and tau_u
    tau_e = apply_rest_monomial(Fq,tau_perm,tau_values,e,n);
    tau_u = apply_rest_monomial(Fq,tau_perm,tau_values,u,n);

    u_Htr = u[_sage_const_0 ,_sage_const_0 :r]+u[_sage_const_0 ,r:n]*Htr_unsys;

    #Hashing, appending commitments to c and storing c0 and c1
    c0_before_hash = str(matrix(tau_perm))+str(tau_values)+str(u_Htr);
    c0 = hashlib.sha256();
    c0.update(c0_before_hash.encode('utf-8'));
    c0 = c0.hexdigest();

    c1_before_hash = str(tau_u)+str(tau_e);
    c1 = hashlib.sha256();
    c1.update(c1_before_hash.encode('utf-8'));
    c1 = c1.hexdigest();

    big_c+=c0+c1;
    comm_hashes.append(c0); 
    comm_hashes.append(c1);

    #Storing the random generated values
    tau_u_matrix[i,:] = tau_u;
    tau_e_matrix[i,:] = tau_e;
    tau_perm_matrix[i,:] = matrix(tau_perm);
    tau_values_matrix[i,:] = tau_values;
    

#verification over N rounds starts    
verifier_c=[]

for j in range(_sage_const_0 ,N):
    
    ##Verifier chooses z
    z = Fq_star.random_element();

    #Prover computes y
    y = tau_u_matrix[j,:]+z*tau_e_matrix[j,:];

    ##Verifier chooses b
    b = GF(_sage_const_2 ).random_element();
    
    #Creating response: for each value of b, we also sen the opposite hash commitment
    if b==_sage_const_0 :
        tau_inv_y = apply_inv_rest_monomial(Fq,vector(tau_perm_matrix[j,:]),tau_values_matrix[j,:],y,n);
        final_val = tau_inv_y[_sage_const_0 ,_sage_const_0 :r]+tau_inv_y[_sage_const_0 ,r:n]*Htr_unsys-z*s;
        prover_c0_before_hash = str(tau_perm_matrix[j,:])+str(tau_values_matrix[j,:])+str(final_val);
        prover_c0 = hashlib.sha256();
        prover_c0.update(prover_c0_before_hash.encode('utf-8'));
        prover_c0 = prover_c0.hexdigest();
        verifier_c+=prover_c0+comm_hashes[_sage_const_2 *j+_sage_const_1 ];
    else:
        final_val = y-z*tau_e_matrix[j,:];
        prover_c1_before_hash = str(final_val)+str(tau_e_matrix[j,:]);
        prover_c1 = hashlib.sha256();
        prover_c1.update(prover_c1_before_hash.encode('utf-8'));
        prover_c1 = prover_c1.hexdigest();
        verifier_c+=comm_hashes[_sage_const_2 *j]+prover_c1;
        
#Final test
if big_c == verifier_c:
    print("Accept!");
else:
    print("Denied!");

