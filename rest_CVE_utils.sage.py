

# This file was *autogenerated* from the file rest_CVE_utils.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1)#Key generation
def key_gen(Fq,n,r):
    Htr_unsys = random_matrix(Fq,n-r,r); #public matrix (only non-systematic portion)
    e = rnd_restricted_vector(Fq,n);
    
    #compute syndrome
    s = e[_sage_const_0 ,_sage_const_0 :r] + e[_sage_const_0 ,r:n]*Htr_unsys;
    return e,Htr_unsys,s;    

##################################################################

#Generate a random vector made of +1 and -1
def rnd_restricted_vector(Fq,n):
    a = convert_restricted(Fq,random_matrix(GF(_sage_const_2 ),_sage_const_1 ,n),n);
    return a;

##################################################################

#Convert binary string to \pm 1 over Fq
def convert_restricted(Fq,a,n):
    b = a.change_ring(ZZ);
    b = _sage_const_2 *b-ones_matrix(ZZ,_sage_const_1 ,n);
    b = b.change_ring(Fq);
    return b;

##################################################################    

#Apply restricted monomial transformation
def apply_rest_monomial(Fq,tau_perm, tau_values, a, n):
    b = matrix(Fq,_sage_const_1 ,n);
    for i in range(_sage_const_0 ,n):
        p = tau_perm[i];
        b[_sage_const_0 ,i] = tau_values[_sage_const_0 ,p]*a[_sage_const_0 ,p]; #tau_values[0,p] andrebbe diviso, ma tanto Ã¨ composto da +1(1) e -1(30), e la divisione corrisponde al quadrato (1*1=1/1=1,-1*-1=-1/-1=1)
    return b;

##################################################################

#Apply inverse of restricted monomial transformation
def apply_inv_rest_monomial(Fq,tau_perm, tau_values, a, n):
    b = matrix(Fq,_sage_const_1 , n);
    for i in range(_sage_const_0 , n):
        p = tau_perm[i];
        b[_sage_const_0 ,p] = a[_sage_const_0 ,i]/tau_values[_sage_const_0 ,p];
    return b;    

##################################################################

##Simulate one round of the protocol
def one_round_sim(Fq,n,r,e,Htr_unsys,s):
    
    ok=_sage_const_0 ;
    
    ##Generating committments
    u = random_matrix(Fq,_sage_const_1 ,n);
    set_random_seed();
    tau_seed = initial_seed();
    tau_perm = P.random_element();
    tau_values  = rnd_restricted_vector(Fq,n);

    tau_e = apply_rest_monomial(Fq,tau_perm,tau_values,e,n);
    tau_u = apply_rest_monomial(Fq,tau_perm,tau_values,u,n);

    u_Htr = u[_sage_const_0 ,_sage_const_0 :r]+u[_sage_const_0 ,r:n]*Htr_unsys;


    #Hashing and sending c0 and c1
    c0_before_hash = str(tau_perm)+str(tau_values)+str(u_Htr);
    c0 = hashlib.sha256();
    c0.update(c0_before_hash.encode('utf-8'));
    c0 = c0.hexdigest();

    c1_before_hash = str(tau_u)+str(tau_e);
    c1 = hashlib.sha256();
    c1.update(c1_before_hash.encode('utf-8'));
    c1 = c1.hexdigest();

    ##Verifier chooses z
    z = Fq_star.random_element();

    #Prover computes y
    y = tau_u + z*tau_e;

    ##Verifier chooses b
    b = GF(_sage_const_2 ).random_element();

    #Creating response
    if b==_sage_const_0 :
        ##Calculating tau from seed
        set_random_seed(tau_seed);
        tau_perm_verifier = P.random_element();
        tau_values_verifier  = rnd_restricted_vector(Fq,n);
        
        tau_inv_y = apply_inv_rest_monomial(Fq,tau_perm_verifier,tau_values_verifier,y,n);
        final_val = tau_inv_y[_sage_const_0 ,_sage_const_0 :r]+tau_inv_y[_sage_const_0 ,r:n]*Htr_unsys-z*s;
        prover_c0_before_hash = str(tau_perm_verifier)+str(tau_values_verifier)+str(final_val);
        prover_c0 = hashlib.sha256();
        prover_c0.update(prover_c0_before_hash.encode('utf-8'));
        prover_c0 = prover_c0.hexdigest();
        if prover_c0 == c0:
            ok=_sage_const_1 ;
    else:
        final_val = y-z*tau_e;
        prover_c1_before_hash = str(final_val)+str(tau_e);
        prover_c1 = hashlib.sha256();
        prover_c1.update(prover_c1_before_hash.encode('utf-8'));
        prover_c1 = prover_c1.hexdigest();
        if prover_c1 == c1:
            ok=_sage_const_1 ;
    return ok;

########################################################################

def multiple_rounds_sim(Fq,n,r,e,Htr_unsys,s,N):


    ##Generating N committments
    big_c_before_hash = ''; #it is the overall commitment
    tau_u_matrix = matrix(Fq,N,n); #it contains the N vectors u, for all rounds
    tau_perm_matrix = matrix(ZZ,N,n); #it contains the N permutations, for all rounds
    tau_values_matrix = matrix(Fq,N,n); #it contains the N scaling vectors, for all rounds
    tau_e_matrix = matrix(Fq,N,n);
    tau_seed_matrix = matrix(ZZ,N,_sage_const_1 ); #it contains the N tau seeds, for all rounds

    comm_hashes=[];    
    #Proceeding with remaining rounds
    for i in range(_sage_const_0 ,N):

        #Generating a random u and a random restricted monomial
        u = random_matrix(Fq,_sage_const_1 ,n);
        set_random_seed();
        tau_seed = initial_seed();
        tau_perm = P.random_element();
        tau_values = rnd_restricted_vector(Fq,n);

        #Apply monomial to tau_e and tau_u
        tau_e = apply_rest_monomial(Fq,tau_perm,tau_values,e,n);
        tau_u = apply_rest_monomial(Fq,tau_perm,tau_values,u,n);

        u_Htr = u[_sage_const_0 ,_sage_const_0 :r]+u[_sage_const_0 ,r:n]*Htr_unsys;

        #Hashing, appending commitments to c and storing c0 and c1
        c0_before_hash = str(matrix(tau_perm))+str(tau_values)+str(u_Htr);
        c0 = hashlib.sha256();
        c0.update(c0_before_hash.encode('utf-8'));
        c0 = c0.hexdigest();

        c1_before_hash = str(tau_u)+str(tau_e);
        c1 = hashlib.sha256();
        c1.update(c1_before_hash.encode('utf-8'));
        c1 = c1.hexdigest();

        big_c_before_hash+=c0+c1;
        comm_hashes.append(c0); 
        comm_hashes.append(c1);

        #Storing the random generated values
        tau_u_matrix[i,:] = tau_u;
        tau_e_matrix[i,:] = tau_e;
        tau_perm_matrix[i,:] = matrix(tau_perm);
        tau_values_matrix[i,:] = tau_values;
        tau_seed_matrix[i,:] =  tau_seed;

    #Final hashed commitment
    big_c = hashlib.sha256();
    big_c.update(big_c_before_hash.encode('utf-8'));
    big_c = big_c.hexdigest();
    big_c_bin = big_c.digits(_sage_const_2 ); #Hashed commitment is converted from HEX to BIN ('list' object from LSB to MSB)
    
    #verification over N rounds starts    
    verifier_c_before_hash=''

    for j in range(_sage_const_0 ,N):

        ##Verifier chooses z
        z = Fq_star.random_element();

        #Prover computes y
        y = tau_u_matrix[j,:]+z*tau_e_matrix[j,:];

        ##Challenge bit b is chosen from hashed commitment (from LSB to MSB)
        b = big_c_bin[j];

        #Creating response: for each value of b, we also sen the opposite hash commitment
        if b==_sage_const_0 :
            #Calculating tau from seeds
            tau_seed = tau_seed_matrix[j,_sage_const_0 ];
            set_random_seed(tau_seed);
            tau_perm_verifier = P.random_element();
            tau_values_verifier  = rnd_restricted_vector(Fq,n);
            
            tau_inv_y = apply_inv_rest_monomial(Fq,vector(tau_perm_verifier),tau_values_verifier,y,n);
            final_val = tau_inv_y[_sage_const_0 ,_sage_const_0 :r]+tau_inv_y[_sage_const_0 ,r:n]*Htr_unsys-z*s;
            prover_c0_before_hash = str(matrix(tau_perm_verifier))+str(tau_values_verifier)+str(final_val);
            prover_c0 = hashlib.sha256();
            prover_c0.update(prover_c0_before_hash.encode('utf-8'));
            prover_c0 = prover_c0.hexdigest();
            verifier_c_before_hash+=prover_c0+comm_hashes[_sage_const_2 *j+_sage_const_1 ];
        else:
            final_val = y-z*tau_e_matrix[j,:];
            prover_c1_before_hash = str(final_val)+str(tau_e_matrix[j,:]);
            prover_c1 = hashlib.sha256();
            prover_c1.update(prover_c1_before_hash.encode('utf-8'));
            prover_c1 = prover_c1.hexdigest();
            verifier_c_before_hash+=comm_hashes[_sage_const_2 *j]+prover_c1;
            
    #Final hashed verified commitment
    verifier_c = hashlib.sha256();
    verifier_c.update(verifier_c_before_hash.encode('utf-8'));
    verifier_c = verifier_c.hexdigest();

    #Final test
    if big_c == verifier_c:
        ok = _sage_const_1 ;
    else:
        ok = _sage_const_0 ;
    return(ok);    
    
    
    
#Zq = Integers(31)
#E = [Zq(2)^i for i in range(multiplicative_order(Zq(2)))]


#pensa a come implementare merkle tree

#fai b con hash m,commitment

